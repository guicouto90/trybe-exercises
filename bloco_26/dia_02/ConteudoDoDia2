//Resumo dia 26.2 Node.js - Fluxo assincrono.
//CALLBACKS:
Exemplo:
const fs = require('fs');

fs.readFile('./arquivo.txt', (err, content) => {
  if (err) {
    console.error(`Erro ao ler o arquivo: ${err.message}`);
    return;
  }

  console.log(`Arquivo lido com sucesso. Conteúdo: ${content.toString('utf8')}`);
});
Fluxo:
1 - Primeiro, pedimos que o Node.js leia o arquivo, e passamos uma função de callback;
2 - Quando a leitura do arquivo é concluída ou um erro acontece, nossa função é chamada;
3 - Dentro dela, a primeira coisa que fazemos é verificar se existe um erro. Caso exista, escrevemos ele no console e encerramos a execução com o return ;
4 - Caso nenhum erro tenha acontecido, sabemos que nosso arquivo foi lido com sucesso e, portanto, seu conteúdo está no segundo parâmetro, que chamamos de content .

***Toda API de módulos nativos do Node.js utiliza esse mesmo formato de callbacks.

DESVANTAGENS DA CALLBACK:
 - A principal desvantagem das callbacks vem do fato de que o resultado de uma operação só existe dentro daquela callback; ou seja: se precisamos executar uma coisa depois da outra, precisamos colocar uma callback dentro da outra.
 Exemplo:
 const fs = require('fs');

fs.readFile('file1.txt', (err, file1Content) => {
  if (err) return console.log(`Erro ao ler arquivo 1: ${err.message}`);

  console.log(`Lido file1.txt com ${file1Content.byteLength} bytes`);

  fs.readFile('file2.txt', (err, file2Content) => {
    if (err) return console.log(`Erro ao ler o arquivo 2: ${err.message}`);

    console.log(`Lido file2.txt com ${file2Content.byteLength} bytes`);

    fs.readFile('file3.txt', (err, file3Content) => {
      if (err) return console.log(`Erro ao ler o arquivo 3: ${err.message}`);

      console.log(`Lido file3.txt com ${file3Content.byteLength} bytes`);
    });
  });
});

//PROMISES:
O conceito de uma Promise, ou um objeto Promise, não é muito diferente da ideia de uma promessa na vida real: alguém se compromete com outra pessoa a fazer algo. Essa promessa pode ser cumprida e, portanto, resolvida , ou algo pode dar errado, fazendo com que não seja possível cumprir a promessa, que será então rejeitada .

CRIANDO UMA PROMISE(ESTRUTURA) :
 - Sempre que precisarmos criar uma nova Promise, invocaremos o construtor através da palavra-chave new . Para esse construtor, devemos passar uma função, que é chamada de executor ; é ela quem vai, de fato, tentar cumprir a promessa que estamos fazendo. A função executor recebe outras duas funções como parâmetros: resolve e reject . Isso tudo fica assim:
 const p = new Promise((resolve, reject) => {
  // Aqui é onde vamos realizar a lógica que precisamos
  // para "tentar cumprir" a promessa
});

const fs = require('fs');

function readFilePromise (fileName) {
  return new Promise((resolve, reject) => {

    fs.readFile(fileName, (err, content) => {
      if (err) return reject(err);
      resolve(content);
    });

  });
}

FLUXO:
1 - Recebemos, como parâmetro, o nome do arquivo que queremos ler, fileName na função readFilePromise(fileName) ;
2 - Criamos e retornamos uma nova Promise, Promise((resolve, reject) => {} ;
3 - Chamamos o módulo nativo do node, fs , para realizar a leitura desse arquivo, fs.readFile(fileName, (err, content) => {}) ;
4 - Dentro da callback fs.readFile(fileName, (err, content) => {}) que passamos para a função readFile , verificamos se ocorreu um erro ( if (err) ). Se sim, rejeitamos a Promise e encerramos a execução - reject(err) ;
5 - Caso não tenha acontecido nenhum erro, resolvemos a Promise com o resultado da leitura do arquivo - resolve(content) .

//LENDO ARQUIVOS COM METODOS ASSINCRONOS


//RESUMO AULA AO VIVO
Por que trabalhar com fluxo assincrono?
Fato de nao precisar de esperar operacoes de alta latencia. Lembrar da fila do McDonalds apos pedir o lanche, a fila funciona de forma assincrona.

AXIOS > fetch

